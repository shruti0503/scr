"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.urlsafe_b64encode = urlsafe_b64encode;
exports.fetchRetry = fetchRetry;
exports.normalizeHeaders = normalizeHeaders;
const logger_js_1 = require("./logger.js");
function urlsafe_b64encode(data) {
    const encoder = new TextEncoder();
    const encoded = encoder.encode(data);
    const base64 = btoa(String.fromCharCode(...encoded))
        .replace(/\+/g, '-')
        .replace(/\//g, '_')
        .replace(/=+$/, '');
    return base64;
}
async function fetchRetry(config, retries = 3, retryDelay = 1000) {
    let lastError = null;
    for (let attempt = 1; attempt <= retries; attempt++) {
        try {
            // XXX: note that cloudflare workers don't support init options
            const { url, ...reqInit } = config;
            const response = await fetch(new Request(url, reqInit));
            // retry 5xx status codes
            if (response.status >= 500 && response.status < 600) {
                const _text = await response.text(); // consume response to prevent leak
                lastError = new Error(`Fetch failed with status: ${response.status}`);
                if (attempt < retries) {
                    logger_js_1.log.debug(`request failed ${response.status} (${_text}): retry ${attempt}/${retries} after ${retryDelay}ms`);
                    await new Promise((resolve) => setTimeout(resolve, retryDelay));
                }
            }
            else {
                return response;
            }
        }
        catch (error) {
            lastError = error;
            if (attempt === retries || error.name === 'AbortError') {
                throw error;
            }
            await new Promise((resolve) => setTimeout(resolve, retryDelay));
        }
    }
    throw lastError;
}
function normalizeHeaders(headers) {
    const normalizedHeaders = {};
    if (headers instanceof Headers) {
        headers.forEach((value, key) => {
            normalizedHeaders[key.toLowerCase()] = value;
        });
    }
    else {
        Object.keys(headers).forEach((key) => {
            normalizedHeaders[key.toLowerCase()] = headers[key];
        });
    }
    return normalizedHeaders;
}
