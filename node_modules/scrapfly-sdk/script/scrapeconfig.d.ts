import type { HttpMethod, Rec } from './types.js';
export declare enum ScreenshotFlags {
    /**
      Options to customize the screenshot behavior
      Attributes:
          LOAD_IMAGES: Enable image rendering with the request, add extra usage for the bandwidth consumed.
          DARK_MODE: Enable dark mode display.
          BLOCK_BANNERS: Block cookies banners and overlay that cover the screen.
          PRINT_MEDIA_FORMAT: Render the page in the print mode.
      */
    LOAD_IMAGES = "load_images",
    DARK_MODE = "dark_mode",
    BLOCK_BANNERS = "block_banners",
    PRINT_MEDIA_FORMAT = "print_media_format",
    HIGH_QUALITY = "high_quality"
}
export declare enum Format {
    /**
      Format of the scraped content.
      Attributes:
          JSON: JSON format.
          TEXT: Text format.
          MARKDOWN: Markdown format.
          CLEAN_HTML: Clean HTML format.
      */
    JSON = "json",
    TEXT = "text",
    MARKDOWN = "markdown",
    CLEAN_HTML = "clean_html",
    RAW = "raw"
}
export declare enum FormatOption {
    NO_LINKS = "no_links",
    NO_IMAGES = "no_images",
    ONLY_CONTENT = "only_content"
}
type ScrapeConfigOptions = {
    url: string;
    retry?: boolean;
    method?: HttpMethod;
    country?: string;
    render_js?: boolean;
    cache?: boolean;
    cache_clear?: boolean;
    cost_budget?: number;
    ssl?: boolean;
    dns?: boolean;
    asp?: boolean;
    debug?: boolean;
    raise_on_upstream_error?: boolean;
    cache_ttl?: number;
    proxy_pool?: string;
    session?: string;
    tags?: string[];
    format?: 'json' | 'text' | 'markdown' | 'clean_html' | 'raw' | Format;
    format_options?: ('no_links' | 'no_images' | 'only_content' | FormatOption)[];
    extraction_template?: string;
    extraction_ephemeral_template?: object;
    extraction_prompt?: string;
    extraction_model?: string;
    correlation_id?: string;
    cookies?: Rec<string>;
    body?: string;
    data?: Rec<any>;
    headers?: Rec<string>;
    js?: string;
    rendering_wait?: number;
    wait_for_selector?: string;
    screenshots?: Rec<any>;
    screenshot_flags?: ('load_images' | 'dark_mode' | 'block_banners' | 'print_media_format' | 'high_quality' | ScreenshotFlags)[];
    session_sticky_proxy?: boolean;
    webhook?: string;
    timeout?: number;
    js_scenario?: Rec<any>;
    os?: string;
    lang?: string[];
    auto_scroll?: boolean;
};
export declare class ScrapeConfig {
    static PUBLIC_DATACENTER_POOL: string;
    static PUBLIC_RESIDENTIAL_POOL: string;
    url: string;
    retry: boolean;
    method: HttpMethod;
    country?: string | null;
    render_js: boolean;
    cache: boolean;
    cache_clear: boolean;
    cost_budget?: number;
    ssl: boolean;
    dns: boolean;
    asp: boolean;
    debug: boolean;
    raise_on_upstream_error: boolean;
    cache_ttl?: number;
    proxy_pool?: string;
    session?: string;
    tags: Set<string>;
    format?: 'json' | 'text' | 'markdown' | 'clean_html' | 'raw' | Format;
    format_options?: ('no_links' | 'no_images' | 'only_content' | FormatOption)[];
    extraction_template?: string;
    extraction_ephemeral_template?: object;
    extraction_prompt?: string;
    extraction_model?: string;
    correlation_id?: string;
    cookies?: Rec<string>;
    body?: string;
    data?: Rec<any>;
    headers?: Rec<string>;
    js?: string;
    rendering_wait?: number;
    wait_for_selector?: string;
    session_sticky_proxy: boolean;
    screenshots?: Rec<any>;
    screenshot_flags?: ('load_images' | 'dark_mode' | 'block_banners' | 'print_media_format' | 'high_quality' | ScreenshotFlags)[];
    webhook?: string;
    timeout?: number;
    js_scenario?: Rec<any>;
    lang?: string[];
    os?: string;
    auto_scroll?: boolean;
    constructor(options: ScrapeConfigOptions);
    private validateOptions;
    toApiParams(options: {
        key: string;
    }): Record<string, any>;
}
export {};
//# sourceMappingURL=scrapeconfig.d.ts.map